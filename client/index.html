<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lakdi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    *{box-sizing:border-box} body{margin:0;font-family:sans-serif;background:#0d2818;color:#fff}
    main{max-width:1100px;margin:auto;padding:20px}
    .hidden{display:none!important}
    .panel{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);border-radius:14px;padding:14px;margin-bottom:14px}
    input{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.3);background:rgba(255,255,255,.1);color:#fff}
    button{padding:8px 14px;border:none;border-radius:8px;cursor:pointer;font-weight:bold;margin:4px;background:#2563eb;color:#fff}
    button:disabled{opacity:.5;cursor:not-allowed}
    /* Opponents row: no overlap, wraps nicely */
    #playersList{display:flex;flex-wrap:wrap;gap:10px}
    #playersList .player{display:flex;justify-content:space-between;align-items:center;gap:8px;min-width:230px;padding:8px;border-radius:8px;background:rgba(255,255,255,.05)}
    .player.current{outline:2px solid #10b981}
    .backs{display:flex;gap:2px}
    .back{width:14px;height:20px;background:linear-gradient(135deg,#2c3e50,#34495e);border:1px solid #3498db;border-radius:2px}
    .card{display:inline-flex;align-items:center;justify-content:center;min-width:80px;height:108px;background:#fff;color:#111;border:2px solid #cbd5e1;border-radius:10px;cursor:pointer;margin:4px;font-size:26px;font-weight:bold}
    .card.selected{transform:translateY(-8px);border-color:#0ea5e9;background:#f0f9ff}
    .card.red{color:#e74c3c} .card.black{color:#111}
    #log{white-space:pre;background:#111;color:#0f0;padding:10px;border-radius:8px;max-height:200px;overflow:auto}
    /* showdown */
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.7);display:flex;align-items:center;justify-content:center;z-index:1000}
    .modal .content{background:#143828;border:1px solid rgba(255,255,255,.2);border-radius:14px;max-width:960px;width:92%;padding:16px;max-height:85vh;overflow:auto}
    .hands{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-top:10px}
    .handBox{background:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:10px}
    .handBox.winner{border-color:#10b981;background:rgba(16,185,129,.25)}
    .handBox.penalty{border-color:#e74c3c;background:rgba(231,76,60,.25)}
    .mini{width:60px;height:84px;background:#fff;color:#111;border:2px solid #cbd5e1;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:800;margin:2px;font-size:18px}
    .mini.red{color:#e74c3c}
    /* table bits kept minimal (stock/discard/timer) */
    .table-bar{display:flex;gap:8px;align-items:center;margin-top:8px}
    .pile{padding:6px 10px;background:#173423;border:1px solid rgba(255,255,255,.2);border-radius:8px}
    .timer{margin-left:auto}
    /* cut section */
    #cutBar{margin-top:6px}
  </style>
</head>
<body>
<main>
  <h1>üÉè Lakdi</h1>

  <!-- Lobby -->
  <section id="lobby" class="panel">
    <input id="playerName" placeholder="Your name"/>
    <button id="createBtn">Create Room</button>
    <input id="roomCode" placeholder="Room code"/>
    <button id="joinBtn">Join Room</button>
    <button id="singleBtn" style="background:#10b981">ü§ñ Play vs Computer</button>
    <div id="lobbyMsg"></div>
  </section>

  <!-- Game -->
  <section id="table" class="hidden">
    <div id="playersPanel" class="panel">
      <div>Room: <span id="roomCodeDisplay"></span></div>
      <button id="startBtn">Start</button>

      <div id="playersList"></div>

      <div class="table-bar">
        <div class="pile">Stock: <span id="stockCount">0</span></div>
        <div class="pile">Discard: <span id="discardTop">Empty</span></div>
        <div class="timer">‚è±Ô∏è <span id="timer">30</span>s</div>
      </div>

      <div style="margin-top:6px">
        <button id="discardBtn" disabled>Discard</button>
        <button id="drawStockBtn" disabled>Draw Stock</button>
        <button id="drawDiscardBtn" disabled>Draw Discard</button>
        <button id="lakdiBtn" disabled title="Available after 1st turn">Call Lakdi</button>
      </div>

      <div id="cutBar" class="hidden">
        <strong>Cut?</strong>
        <button id="cutBtn" style="background:#ef4444">Cut</button>
        <button id="passBtn" style="background:#475569">Pass</button>
      </div>
    </div>

    <div class="panel">
      <h3>Your Hand</h3>
      <div id="hand"></div>
      <h3>Log</h3>
      <pre id="log"></pre>
    </div>
  </section>

  <!-- Showdown -->
  <div id="showdownModal" class="modal hidden">
    <div class="content">
      <h2>Round Results</h2>
      <div id="showdownInfo"></div>
      <div class="hands" id="handsGrid"></div>
      <button id="closeShowdown">Close</button>
    </div>
  </div>
</main>

<script>
/* ========= Core State ========= */
const sym={hearts:"‚ô•",diamonds:"‚ô¶",clubs:"‚ô£",spades:"‚ô†"};
const isRed=s=>s==="hearts"||s==="diamonds";
const val=r=>r==="A"?1:r==="J"?11:r==="Q"?12:r==="K"?13:parseInt(r,10);
const sum=h=>h.reduce((t,c)=>t+val(c.rank),0);

const $=id=>document.getElementById(id);
const log=(...a)=>{ const el=$("log"); el.textContent+=a.join(" ")+"\\n"; el.scrollTop=el.scrollHeight; };

let state={
  mode:"lobby",
  single:false,
  players:[],
  myId:null,
  currentTurn:null,
  deck:[],
  hands:{},
  discard:[],
  /* NEW: snapshot of top-of-discard available to the current player AFTER they discard */
  turnPrevTop:null,
  timer:null, timeLeft:30,
  firstTurn:true,
  lakdiCaller:null,
  cutPhase:false
};

const cardLabel=c=>`${c.rank}${sym[c.suit]}`;
const buildDeck=(decks=1)=>{
  const s=['hearts','diamonds','clubs','spades'], r=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const d=[]; for(let k=0;k<decks;k++){ for(const ss of s){ for(const rr of r){ d.push({suit:ss,rank:rr}); } } }
  for(let i=d.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [d[i],d[j]]=[d[j],d[i]]; }
  return d;
};

function resetTimerUI(){ $("timer").textContent="30"; }
function startTimer(){
  clearInterval(state.timer); state.timeLeft=30; $("timer").textContent=state.timeLeft;
  state.timer=setInterval(()=>{
    state.timeLeft--; $("timer").textContent=state.timeLeft;
    if(state.timeLeft<=0){
      clearInterval(state.timer);
      // auto: discard lowest single then draw stock
      if(state.currentTurn===state.myId && handOf(state.myId).length===3){
        const h=handOf(state.myId);
        const idx = h.reduce((min,i,ix,arr)=> val(arr[ix].rank)<val(arr[min].rank)?ix:min,0);
        setSelected([idx]); doDiscard(); setTimeout(()=> doDraw('stock'), 400);
      } else if(state.single && state.currentTurn!=="you") {
        aiTurn();
      }
    }
  },1000);
}
function stopTimer(){ clearInterval(state.timer); }

/* ===== Lobby (local demo) ===== */
$("createBtn").onclick=()=>{
  const name=$("playerName").value.trim()||"You";
  state.single=false;
  state.players=[{id:"you",name,score:0},{id:"p2",name:"P2",score:0}];
  state.myId="you"; $("roomCodeDisplay").textContent="LOCAL";
  $("lobbyMsg").textContent="Room created (local demo).";
  showGame(); startRound();
};
$("joinBtn").onclick=()=>{
  const name=$("playerName").value.trim()||"You";
  state.single=false;
  state.players=[{id:"you",name,score:0},{id:"p2",name:"P2",score:0},{id:"p3",name:"P3",score:0}];
  state.myId="you"; $("roomCodeDisplay").textContent="LOCAL";
  $("lobbyMsg").textContent="Joined (local demo).";
  showGame(); startRound();
};
$("singleBtn").onclick=()=>{
  const name=$("playerName").value.trim()||"You";
  state.single=true;
  state.players=[{id:"you",name,score:0},{id:"ai1",name:"Asha (easy)",score:0},{id:"ai2",name:"Bala (medium)",score:0},{id:"ai3",name:"Chetan (hard)",score:0}];
  state.myId="you"; $("roomCodeDisplay").textContent="CPU";
  $("lobbyMsg").textContent="Single-player vs bots.";
  showGame(); startRound();
};
$("startBtn").onclick=()=> startRound();

function showLobby(){ $("lobby").classList.remove("hidden"); $("table").classList.add("hidden"); }
function showGame(){ $("lobby").classList.add("hidden"); $("table").classList.remove("hidden"); }

/* ===== Round setup ===== */
function startRound(){
  state.mode="playing";
  stopTimer(); resetTimerUI();  /* <-- timer hard reset every round */
  const decks=Math.ceil(state.players.length/6)||1;
  state.deck=buildDeck(decks);
  state.hands={};
  state.players.forEach(p=>{ state.hands[p.id]=[state.deck.pop(),state.deck.pop(),state.deck.pop()]; });

  // Initial visible discard (previously rejected card)
  state.discard=[state.deck.pop()];
  state.currentTurn=state.players[0].id;
  /* NEW: snapshot the top card that is eligible to be taken from discard this turn */
  state.turnPrevTop = state.discard[state.discard.length-1];
  state.firstTurn=true;
  state.lakdiCaller=null;
  state.cutPhase=false;

  renderAll();
  if(state.currentTurn===state.myId) startTimer();
  else if(state.single) aiTurn();
}

/* ===== Rendering ===== */
function handOf(id){ return state.hands[id]||[]; }

function renderPlayers(){
  const list=$("playersList"); list.innerHTML="";
  state.players.forEach(p=>{
    const row=document.createElement("div"); row.className="player"+(state.currentTurn===p.id?" current":"");
    const left=document.createElement("span"); left.textContent=`${p.name} (${p.score||0})`;
    const right=document.createElement("span");
    const backs=document.createElement("span"); backs.className="backs";
    const len=handOf(p.id).length;
    for(let i=0;i<len;i++){ const b=document.createElement("span"); b.className="back"; backs.appendChild(b); }
    const badge=document.createElement("span"); badge.style.marginLeft="6px"; badge.textContent=`${len} cards`;
    right.appendChild(backs); right.appendChild(badge);
    row.appendChild(left); row.appendChild(right);
    list.appendChild(row);
  });
}

let selected=[]; // indices in my hand
function setSelected(a){ selected=a; renderHand(); }

function renderHand(){
  const wrap=$("hand"); wrap.innerHTML="";
  const mine=handOf(state.myId);
  mine.forEach((c,i)=>{
    const el=document.createElement("div"); el.className=`card ${isRed(c.suit)?'red':'black'}`; el.textContent=cardLabel(c);
    if(selected.includes(i)) el.classList.add("selected");
    el.onclick=()=>onCardClick(i);
    wrap.appendChild(el);
  });
  updateButtons();
}

function renderBars(){
  $("stockCount").textContent=state.deck.length;
  $("discardTop").textContent = state.discard.length ? cardLabel(state.discard[state.discard.length-1]) : "Empty";
}

function renderAll(){ renderPlayers(); renderHand(); renderBars(); updateButtons(); }

/* ===== Selection: 1‚Äì3 of the same rank only ===== */
function onCardClick(i){
  if(state.currentTurn!==state.myId) return;
  const mine=handOf(state.myId); if(mine.length!==3) return;

  const already=selected.includes(i);
  if(already){
    selected = selected.filter(x=>x!==i);
  }else{
    const r = mine[i].rank;
    if(selected.length){
      const r0 = mine[selected[0]].rank;
      if(r!==r0) selected=[];  // force same rank
    }
    if(selected.length<3) selected.push(i);
  }
  renderHand();
}

function validDiscard(){
  if(selected.length<1 || selected.length>3) return false;
  if(selected.length===1) return true;
  const mine=handOf(state.myId);
  const r0=mine[selected[0]].rank;
  return selected.every(ix=>mine[ix].rank===r0);
}

/* ===== Buttons ===== */
function updateButtons(){
  const myTurn = state.currentTurn===state.myId;
  const mineLen = handOf(state.myId).length;

  $("discardBtn").disabled = !(myTurn && mineLen===3 && validDiscard());

  const canDraw = myTurn && mineLen===2;
  $("drawStockBtn").disabled = !canDraw;

  /* NEW: only allow Draw Discard if the turn snapshot exists (the last rejected card from previous player) */
  $("drawDiscardBtn").disabled = !(canDraw && state.turnPrevTop);

  $("lakdiBtn").disabled = !(myTurn && !state.firstTurn && mineLen===3 && !state.cutPhase);
  $("cutBar").classList.toggle("hidden", !(state.cutPhase && state.lakdiCaller!==state.myId));
}

/* ===== Actions ===== */
$("discardBtn").onclick = ()=> doDiscard();
$("drawStockBtn").onclick = ()=> doDraw('stock');
$("drawDiscardBtn").onclick = ()=> doDraw('discard');
$("lakdiBtn").onclick = ()=> doLakdi(state.myId);
$("cutBtn").onclick = ()=> doCutAttempt(state.myId);
$("passBtn").onclick = ()=> doPass(state.myId);

function doDiscard(){
  if(!validDiscard()) return;
  const mine=handOf(state.myId);

  // Remove selected and push LAST one as the visible discard
  const indices=[...selected].sort((a,b)=>a-b);
  const thrown = indices.map(i=>mine[i]);
  for(let k=indices.length-1;k>=0;k--) mine.splice(indices[k],1);

  // The card visible to everyone becomes the LAST discarded
  state.discard.push(thrown[thrown.length-1]);

  selected=[];
  renderHand(); renderBars(); updateButtons();
}

function reshuffleIfNeeded(){
  if(state.deck.length===0 && state.discard.length>1){
    const top = state.discard.pop();
    state.deck = [...state.discard];
    state.discard=[top];
    for(let i=state.deck.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [state.deck[i],state.deck[j]]=[state.deck[j],state.deck[i]]; }
  }
}

function doDraw(src){
  if(state.currentTurn!==state.myId) return;
  const mine=handOf(state.myId); if(mine.length!==2) return;

  if(src==='stock'){
    reshuffleIfNeeded();
    if(state.deck.length){ mine.push(state.deck.pop()); }
  }else{
    /* NEW: draw the "last rejected card" from before you discarded (turnPrevTop), not your own discard */
    if(!state.turnPrevTop) return;
    // remove that specific card from the pile (it is now under your own discard)
    const idx = state.discard.findIndex(c=>c===state.turnPrevTop);
    if(idx>=0){ const [card]=state.discard.splice(idx,1); mine.push(card); }
    state.turnPrevTop=null; // used
  }

  state.firstTurn=false;
  renderHand(); renderBars(); updateButtons();
  endTurn();
}

function beginTurnFor(nextId){
  state.currentTurn = nextId;
  /* NEW: snapshot the currently visible discard as this player's eligible draw-from-discard */
  state.turnPrevTop = state.discard[state.discard.length-1] || null;
  renderPlayers(); updateButtons(); stopTimer(); resetTimerUI();
  if(state.currentTurn===state.myId) startTimer();
  else if(state.single) aiTurn();
}

function endTurn(){
  const idx=state.players.findIndex(p=>p.id===state.currentTurn);
  const next = state.players[(idx+1)%state.players.length].id;
  beginTurnFor(next);
}

/* ===== Lakdi / Cut ===== */
function doLakdi(callerId){
  state.lakdiCaller=callerId;
  state.cutPhase=true; updateButtons(); stopTimer();

  if(state.single){
    if(callerId!==state.myId){
      log("Bot called Lakdi. You may Cut or Pass.");
    }else{
      setTimeout(()=> botsCutPass(), 400);
    }
  }else{
    setTimeout(()=> botsCutPass(), 400);
  }
}

function doCutAttempt(cutterId){
  const totals = computeTotals();
  const valid = totals[cutterId] <= totals[state.lakdiCaller];
  if(valid){ endRound({penaltyOn: state.lakdiCaller}); }
  else{ endRound({penaltyOn: cutterId}); }
}
function doPass(){ endRound({penaltyOn:null}); }

function botsCutPass(){
  const totals=computeTotals(), caller=state.lakdiCaller;
  const opps=state.players.filter(p=>p.id!==caller);
  const cutter = opps.find(p=> totals[p.id] <= totals[caller]);
  if(cutter) endRound({penaltyOn: caller});
  else endRound({penaltyOn: null});
}

function computeTotals(){ const t={}; state.players.forEach(p=> t[p.id]=sum(handOf(p.id))); return t; }

function endRound({penaltyOn}){
  const totals = computeTotals();
  const winnerId = Object.entries(totals).sort((a,b)=>a[1]-b[1])[0][0];

  state.players.forEach(p=>{
    let add = (p.id===winnerId)?0:totals[p.id];
    if(p.id===penaltyOn) add += 50; // flat 50
    p.score = (p.score||0)+add;
  });

  renderShowdown({winnerId, totals, penaltyOn});
}

function renderShowdown({winnerId, totals, penaltyOn}){
  $("showdownInfo").textContent = `Winner: ${state.players.find(p=>p.id===winnerId)?.name||''}`;
  const grid=$("handsGrid"); grid.innerHTML="";
  state.players.forEach(p=>{
    const box=document.createElement("div");
    box.className="handBox"+(p.id===winnerId?" winner":"")+(penaltyOn===p.id?" penalty":"");
    const cards = handOf(p.id).map(c=>`<div class="mini ${isRed(c.suit)?'red':''}">${cardLabel(c)}</div>`).join("");
    box.innerHTML = `
      <div><strong>${p.name}</strong></div>
      <div style="display:flex;flex-wrap:wrap">${cards}</div>
      <div>Round: ${(p.id===winnerId?0:totals[p.id]) + (penaltyOn===p.id?50:0)}</div>
      ${p.id===winnerId?'<div style="color:#10b981;font-weight:700">Winner</div>':''}
      ${penaltyOn===p.id?'<div style="color:#ef4444;font-weight:700">Penalty +50</div>':''}
    `;
    grid.appendChild(box);
  });
  $("showdownModal").classList.remove("hidden");
}

$("closeShowdown").onclick=()=>{
  $("showdownModal").classList.add("hidden");
  // End condition (fixed 200 here)
  const max=Math.max(...state.players.map(p=>p.score||0));
  if(max>=200){ log("Game over."); return; }
  startRound();
};

/* ===== AI (uses same turnPrevTop rule) ===== */
function aiTurn(){
  if(!state.single || state.currentTurn===state.myId) return;
  const aiId = state.currentTurn;

  // snapshot eligible discard for AI this turn
  const prevTop = state.turnPrevTop;

  setTimeout(()=>{
    const h=handOf(aiId);
    // choose discard: prefer pairs/triples, else highest
    const map={}; h.forEach((c,i)=>{ (map[c.rank]??=[]).push(i); });
    let toThrowIdx = Object.values(map).find(a=>a.length>=2) || [ h.reduce((m,_,ix)=> val(h[ix].rank)>val(h[m].rank)?ix:m,0) ];
    const thrownCard = h[toThrowIdx[toThrowIdx.length-1]];
    toThrowIdx.sort((a,b)=>b-a).forEach(i=>h.splice(i,1));
    state.discard.push(thrownCard);
    renderBars();

    setTimeout(()=>{
      // choose draw: MAY draw prevTop only (not own discard)
      const chooseDiscard = prevTop && val(prevTop.rank)<=4; // simple heuristic
      if(chooseDiscard){
        // remove that specific prevTop from pile (it sits under the new top now)
        const idx = state.discard.findIndex(c=>c===prevTop);
        if(idx>=0){ const [card]=state.discard.splice(idx,1); h.push(card); }
      }else{
        if(state.deck.length===0) reshuffleIfNeeded();
        if(state.deck.length) h.push(state.deck.pop());
      }
      state.firstTurn=false;
      // next player
      const curIdx=state.players.findIndex(p=>p.id===aiId);
      const nextId=state.players[(curIdx+1)%state.players.length].id;
      beginTurnFor(nextId);
    },500);
  },500);
}

/* ===== Boot ===== */
document.addEventListener('DOMContentLoaded',()=>{ showLobby(); });
</script>
</body>
</html>
